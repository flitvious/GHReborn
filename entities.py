import libtcodpy as libtcod
import logger
import math
import enums

class Entity:
	"""
	This is a generic game entity. Actors inherit from it (and items, projectiles will)
	Should this be virtual?
	"""
	
	types = enums.enum('Entity', 'Actor')
	
	# use static properties to init what u need
	#profession = enums.enum('Fighter', 'Mage')

	def __init__(self, char, name, color, blocks):
		"""
		Initializes a basic entity.
		"""
		
		self.char = char
		self.color = color
		self.name = name

		# map-specific stuff
		# these are none, added when zone sets them
		self.x = None
		self.y = None
		self.zone = None
		# whether it blocks passage
		self.blocks = blocks
		
	def entity_type(self):
		"""
		Returns own type of entity in Entity.types.*
		Each child redefines this.
		"""
		#raise NotImplementedError("Subclass must implement abstract method")
		return Entity.types.Entity

	def set_zone(self, zone, x, y):
		"""
		Sets entity's zone and positions the object at coords.
		"""
		self.zone = zone
		self.x = x
		self.y = y

class Actor(Entity):
	"""
	An entity that can act, take turns and have stats dict.
	ai component must be passed as a constant: entities.AI.ais.basic_monster
	"""
	designs = enums.enum('orc', 'troll', 'player')
	
	def __init__(self, char, name, color, blocks, 
		ai, design):
		# design for now is a const that points to stats preset. Later it can point to a design file or something.
		# stats dict is static for now and is generated "on spot". Later it can be generated by name from data.

		# call Entity's constructor class to setup the child
		super(Actor, self).__init__(char, name, color, blocks)
		
		# setup ai (it is a component, so will need an owner)
		if ai == AI.ais.player:
			# this ai just asks player for input
			self.ai = PlayerControl(owner=self)
			logger.log(logger.types.ai, "player ai assigned to " + self.name)
		elif ai == AI.ais.basic_monster:
			self.ai = BasicMonster(owner=self)
			logger.log(logger.types.ai, "basic_monster ai assigned to " + self.name)
		else:
			logger.error("Can't pick ai for an actor")
		
		# setup stats based on id, hardcoded (later take from data files)
		if design == Actor.designs.player:
			self.stats = dict(hp=30, defense=2, power=5)
		elif design == Actor.designs.orc:
			self.stats = dict(hp=10, defense=2, power=5)
		elif design == Actor.designs.troll:
			self.stats = dict(hp=16, defense=1, power=4)
		else:
			logger.error("Can't pick design for an actor")

	def entity_type(self):
		"""
		Returns own type of entity in Entity.types.*. For now is used by main to call actor's act().
		"""
		return Entity.types.Actor

	def act(self, ai_data):
		"""
		This method is called each turn for all actors in the map.
		For now it gets ai to work based on its type. 
		inbound params are universal structure. Make it into an object and pass to every actor.
		
		ai_data - AIdata object
		"""
		# for now we just need to call an ai properly
		ai_type = self.ai.get_type()

		if ai_type == AI.ais.player:
			# make player act
			# TODO
			self.ai.work(blah)
		elif ai_type == AI.ais.basic_monster:
			# we need to feed player and fov_map to it
			self.ai.work(player=ai_data.player, fov_map=ai_data.fov_map)
		else:
			pass

### misc stuff for actor

	def move(self, dx, dy):
		"""move by the given amount"""
		# check if blocked by wall or entity
		if not self.zone.is_blocked(self.x + dx, self.y + dy):
			# not blocked, move there
			self.x += dx
			self.y += dy
			logger.log(logger.types.movement, self.name + " moved to " + str((self.x, self.y)))
		else:
			# zone is blocked, let's try to bump into object!
			entity = self.zone.entity_at(self.x + dx, self.y + dy)
			if not entity is None:
				#it is an entity
				self.bump(entity)
			else:
				#it is a wall
				logger.log(logger.types.combat, 'The ' + self.name + ' bumps into a wall. Ugh.')
				pass

	def step_towards(self, target_x, target_y):
		"""
		Moves one tile towards target coords
		"""
		#vector from this object to the target, and distance
		dx = target_x - self.x
		dy = target_y - self.y
		distance = math.sqrt(dx ** 2 + dy ** 2)

		#normalize it to length 1 (preserving direction), then round it and
		#convert to integer so the movement is restricted to the map grid
		dx = int(round(dx / distance))
		dy = int(round(dy / distance))
		self.move(dx, dy)

	def distance_to(self, other):
		"""
		Returns distance to another object
		"""
		dx = other.x - self.x
		dy = other.y - self.y
		return math.sqrt(dx ** 2 + dy ** 2)


### CUT HERE ####

	def bump(self, ent):
		"""bumps into an entity (this gets called for entities only, not for walls)"""
		# this handles collision. 
		# This shound check what type of object we are and handle collision properly (spell-to-actor comes to mind)
		# for now it is a dirty hack for player (who is not-sentient and without ai!) to attact anything sentient and fighter-like!
		# FIXME
		if (not self.fighter is None) and (not obj.fighter is None) and (obj.ai is None) and (not obj is self):
			self.fighter.attack(obj)

	def take_damage(self, damage):
		"""apply damage if possible"""
		if damage > 0:
			self.hp -= damage

	def attack(self, target):
		"""attack another object (must have fighter component)"""
		#a simple formula for attack damage
		damage = self.power - target.fighter.defense
 
		if damage > 0:
			#make the target take some damage
			logger.game(self.owner.name.capitalize() + ' attacks ' + target.name + ' for ' + str(damage) + ' hit points.')
			target.fighter.take_damage(damage)
		else:
			logger.game(self.owner.name.capitalize() + ' attacks ' + target.name + ' but it has no effect!')


#### AIs #####
class AIData:
	"""
	This component is passed as a data for AI to work into actor's act(). It holds all the required parameters.
	Act() then parses that based on ai type. This structure is to be created once and then passed to all the actors.
	"""
	def __init__(self, player, fov_map):
		self.player = player
		self.fov_map = fov_map

class AI:
	"""
	Base class for all AIs
	"""
	ais = enums.enum('base', 'player', 'basic_monster')

	def __init__(self, owner):
		self.owner = owner

	def get_type(self):
		""" children should redefine this"""
		return AI.ais.base

	def work(self):
		""" children should redefine this"""
		raise NotImplementedError("Subclass must implement abstract method")

class BasicMonster(AI):
	"""
	Component AI for a basic monster
	"""
	def get_type(self):
		"""returns type of ai"""
		return AI.ais.basic_monster

	def work(self, player, fov_map):
		"""
		Chase and try to attack. Needs to know where the player is and if she can see the monster.
		"""
		#a basic monster takes its turn. If you can see it, it can see you
		monster = self.owner
		#logger.log(logger.types.ai, monster.name + " takes turn")

		if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):
			#move towards player if far away
			if monster.distance_to(player) >= 2:
				monster.step_towards(player.x, player.y)
			elif player.fighter.hp > 0:
				#close enough, attack! (if the player is still alive.)
				monster.fighter.attack(player)

class PlayerControl(AI):
	"""
	Controlled by human player
	"""
	def get_type(self):
		"""returns type of ai"""
		return AI.ais.player

	def work(self):
		"""
		Take controls from player and work.
		"""
		pass